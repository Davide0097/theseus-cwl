// export const FlowEditorComponent = (props: EditorComponentProps) => {
//   const [refreshKey, setRefreshKey] = useState(0);

//   const initialNodes = useInitializeNodes(props.cwlWorkflow, refreshKey);
//   const initialEdges = useInitializeEdges(props.cwlWorkflow);

//   const [nodes, setNodes, onNodesChange] = useNodesState([...initialNodes]);
//   const [edges, setEdges, onEdgesChange] = useEdgesState([...initialEdges]);
//   // ðŸ” Manually update nodes and edges when refreshed
//   useEffect(() => {
//     setNodes(initialNodes);
//     setEdges(initialEdges);
//   }, [ setNodes, setEdges]);
//   const onConnect = useCallback(
//     (connection: Connection) => setEdges((eds) => addEdge(connection, eds)),
//     [setEdges]
//   );

//   const handleAddNode = useCallback(() => {
//     const newInput: CWLFileInput = {
//       id: "zip_file2",
//       content: {
//         type: "File",
//       },
//     };

//     props.cwlWorkflow.addInput([newInput]);
//   }, [props.cwlWorkflow]);

//   useEffect(() => {
//     const listener = () => {
//       console.log(props.cwlWorkflow);
//       setRefreshKey((prev) => prev + 1);
//     };

//     (props.cwlWorkflow.cwlObject as any).addListener(listener);

//   }, [props.cwlWorkflow, setNodes]);

//   return (
//     <>
//       <ReactFlow
//         nodes={nodes}
//         edges={edges}
//         nodesDraggable={!props.readonly}
//         nodesConnectable={!props.readonly}
//         elementsSelectable={!props.readonly}
//         onNodesChange={props.readonly ? undefined : onNodesChange}
//         onEdgesChange={props.readonly ? undefined : onEdgesChange}
//         onConnect={props.readonly ? undefined : onConnect}
//       >
//         <Controls />

//         <MiniMap nodeColor={(node) => node.style?.backgroundColor as string} />
//         <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
//         <button className="add-node" onClick={handleAddNode}>
//           Add Node
//         </button>
//       </ReactFlow>
//     </>
//   );
// };

// export const FlowEditorComponent = (props: EditorComponentProps) => {
//   const initialNodes = useInitializeNodes(props.cwlWorkflow);
//   const initialEdges = useInitializeEdges(props.cwlWorkflow);

//   const [nodes, setNodes, onNodesChange] = useNodesState([...initialNodes]);
//   const [edges, setEdges, onEdgesChange] = useEdgesState([...initialEdges]);

//   const onConnect = useCallback(
//     (connection: Connection) => setEdges((eds) => addEdge(connection, eds)),
//     [setEdges]
//   );

//   // Callback for adding a new node
//   const handleAddNode = useCallback(() => {
//     const newNode = {
//       id: "newNodeId",
//       data: { label: "New Node" },
//       position: { x: 100, y: 100 },
//     };

//     // Create new input for the node
//     const newInput: CWLFileInput = {
//       id: "newInputId",
//       content: {
//         type: "string",
//       },
//     };

//     // Update the CWL object in a way that React knows about the change
//     const updatedCwlObject = props.cwlWorkflow.addInput([newInput]);

//     // // Now trigger a re-render of the component by updating the state of `cwlWorkflow`
//     props.onChange({ ...props.cwlWorkflow, cwlObject: updatedCwlObject });

//     // You can also add the new node to the state if required
//     setNodes((prevNodes) => [...prevNodes, newNode]);
//   }, [props]);

//   return (
//     <ReactFlow
//       nodes={nodes}
//       edges={edges}
//       nodesDraggable={!props.readonly}
//       nodesConnectable={!props.readonly}
//       elementsSelectable={!props.readonly}
//       onNodesChange={props.readonly ? undefined : onNodesChange}
//       onEdgesChange={props.readonly ? undefined : onEdgesChange}
//       onConnect={props.readonly ? undefined : onConnect}
//     >
//       <Controls />
//       <button onClick={handleAddNode}>Add Node</button>
//       <MiniMap nodeColor={(node) => node.style?.backgroundColor as string} />
//       <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
//     </ReactFlow>
//   );
// };export class DeepObservableObject<OBJECT> {
//   private listeners: Array<(key: string, value: any) => void> = [];
//   private proxy: OBJECT;

//   constructor(initialObject: object = {}) {
//     this.proxy = this.createObservable(initialObject);

//     (this.proxy as any).addListener = this.addListener.bind(this);
//     (this.proxy as any).notifyListeners = this.notifyListeners.bind(this);
//   }
 
//   get data():OBJECT {
//     return this.proxy;
//   }

//   private createObservable(obj: any): any {
//     if (typeof obj !== "object" || obj === null) return obj;

//     return new Proxy(obj, {
//       get: (target, prop, receiver) => {
//         const value = target[prop];
//         return this.createObservable(value); // Recursively make nested objects observable
//       },
//       set: (target, prop, value) => {
//         target[prop] = value;
//         this.notifyListeners(prop as string, value);
//         return true;
//       },

//     });
//   }

//   addListener(listener: (key: string, value: any) => void) {
//     this.listeners.push(listener);
//   }

//   private notifyListeners(key: string, value: any) {
//     this.listeners.forEach((listener) => listener(key, value));
//   }
// }

type ItemType = "type1" | "type2";

export class Item<T = ItemType> {
  type: T;
  id: string;

  constructor(id: string) {
    this.id = id;
  }
}

export class ItemWithNext extends Item {
  next?: Item;

  constructor(id: string, next?: Item) {
    super(id);
    this.next = next;
  }
}

export class ItemWithPrevious extends Item {
  previous?: Item;

  constructor(id: string, previous?: Item) {
    super(id);
    this.previous = previous;
  }
}

export class List {
  items: Item[] = [];

  addItem(item: Item): void {
    this.items.push(item);
  }

  removeItem(id: string): void {
    this.items = this.items.filter((item) => item.id !== id);
  }

  findItem(id: string): Item | undefined {
    return this.items.find((item) => item.id === id);
  }
}

export class ListController {
  private list_: List;

  constructor() {
    this.list_ = new List();
  }

  addItemToList(item: Item): void {
    this.list_.addItem(item);
  }

  removeItemFromList(id: string): void {
    this.list_.removeItem(id);
  }

  getItem(id: string): Item | undefined {
    return this.list_.findItem(id);
  }
}

export class ListView {
  private controller: ListController;

  constructor() {
    this.controller = new ListController();
  }
}

export type ListComponentProps = {};

export const ListComponent = (props: ListComponentProps) => {
  const [items, setItems] = useState<Item[]>();
  const listView = new ListView();

  useEffect(() => {
    setItems([]);
  }, []);

  return (
    <div>
      {(items as []).map((item: Item) => {
        return <ItemComponent />;
      })}
    </div>
  );
};

export type ItemComponentProps = {};

export const ItemComponent = (props: ItemComponentProps) => {
  return <p></p>;
};